// Code generated by protoc-gen-go.
// source: task_execution.proto
// DO NOT EDIT!

/*
Package ga4gh_task_exec is a generated protocol buffer package.

It is generated from these files:
	task_execution.proto

It has these top-level messages:
	TaskParameter
	DockerExecutor
	Volume
	Resources
	Task
	JobListRequest
	TaskDesc
	JobDesc
	JobListResponse
	JobID
	JobLog
	Job
	ServiceInfoRequest
	ServiceInfo
*/
package ga4gh_task_exec

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/grpc-ecosystem/grpc-gateway/third_party/googleapis/google/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type State int32

const (
	State_Unknown     State = 0
	State_Queued      State = 1
	State_Running     State = 2
	State_Paused      State = 3
	State_Complete    State = 4
	State_Error       State = 5
	State_SystemError State = 6
	State_Canceled    State = 7
)

var State_name = map[int32]string{
	0: "Unknown",
	1: "Queued",
	2: "Running",
	3: "Paused",
	4: "Complete",
	5: "Error",
	6: "SystemError",
	7: "Canceled",
}
var State_value = map[string]int32{
	"Unknown":     0,
	"Queued":      1,
	"Running":     2,
	"Paused":      3,
	"Complete":    4,
	"Error":       5,
	"SystemError": 6,
	"Canceled":    7,
}

func (x State) String() string {
	return proto.EnumName(State_name, int32(x))
}
func (State) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// Parameters for Task
type TaskParameter struct {
	// OPTIONAL
	// name of the parameter
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// OPTIONAL
	// Text description
	Description string `protobuf:"bytes,2,opt,name=description" json:"description,omitempty"`
	// REQUIRED
	// location in long term storage, is a url specific to the implementing
	// system. For example s3://my-object-store/file1 or gs://my-bucket/file2 or
	// file:///path/to/my/file
	Location string `protobuf:"bytes,3,opt,name=location" json:"location,omitempty"`
	// REQUIRED
	// path in the machine file system. Note, this MUST be a path that exists
	// within one of the defined volumes
	// If the file is mounted in a volume that is mounted read/write the file must
	// be accessable to processes in the container. Optimizations, suc as hard linking
	// to a source file, or providing a streaming input from a FUSE mount should only
	// be done if the volume is mounted as read only
	Path string `protobuf:"bytes,4,opt,name=path" json:"path,omitempty"`
	// REQUIRED
	// Type of data, "File" or "Directory"
	// if used for an output all the files in the directory
	// will be copied to the storage location
	Class string `protobuf:"bytes,5,opt,name=class" json:"class,omitempty"`
	// OPTIONAL: default false
	// if the parameter is an output, should the element be created before executing
	// the command. For example if saving the working directory as an output,
	// the directory needs to exist before the command is called. If false, it is
	// assumed that the user will create the element as a part of the operation
	Create bool `protobuf:"varint,6,opt,name=create" json:"create,omitempty"`
}

func (m *TaskParameter) Reset()                    { *m = TaskParameter{} }
func (m *TaskParameter) String() string            { return proto.CompactTextString(m) }
func (*TaskParameter) ProtoMessage()               {}
func (*TaskParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *TaskParameter) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TaskParameter) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *TaskParameter) GetLocation() string {
	if m != nil {
		return m.Location
	}
	return ""
}

func (m *TaskParameter) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *TaskParameter) GetClass() string {
	if m != nil {
		return m.Class
	}
	return ""
}

func (m *TaskParameter) GetCreate() bool {
	if m != nil {
		return m.Create
	}
	return false
}

// A command line to be executed and the docker container to run it
type DockerExecutor struct {
	// REQUIRED
	// Docker Image name
	ImageName string `protobuf:"bytes,1,opt,name=imageName" json:"imageName,omitempty"`
	// REQUIRED
	// The command to be executed
	Cmd []string `protobuf:"bytes,2,rep,name=cmd" json:"cmd,omitempty"`
	// OPTIONAL: default docker image directory
	// The working directory that the command will be executed in
	Workdir string `protobuf:"bytes,3,opt,name=workdir" json:"workdir,omitempty"`
	// OPTIONAL
	// Path for supplying input to stdin, blank if none
	Stdin string `protobuf:"bytes,6,opt,name=stdin" json:"stdin,omitempty"`
	// OPTIONAL
	// Path for stdout recording, blank if not storing to file
	Stdout string `protobuf:"bytes,4,opt,name=stdout" json:"stdout,omitempty"`
	// OPTIONAL
	// Path for stderr recording, blank if not storing to file
	Stderr string `protobuf:"bytes,5,opt,name=stderr" json:"stderr,omitempty"`
}

func (m *DockerExecutor) Reset()                    { *m = DockerExecutor{} }
func (m *DockerExecutor) String() string            { return proto.CompactTextString(m) }
func (*DockerExecutor) ProtoMessage()               {}
func (*DockerExecutor) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *DockerExecutor) GetImageName() string {
	if m != nil {
		return m.ImageName
	}
	return ""
}

func (m *DockerExecutor) GetCmd() []string {
	if m != nil {
		return m.Cmd
	}
	return nil
}

func (m *DockerExecutor) GetWorkdir() string {
	if m != nil {
		return m.Workdir
	}
	return ""
}

func (m *DockerExecutor) GetStdin() string {
	if m != nil {
		return m.Stdin
	}
	return ""
}

func (m *DockerExecutor) GetStdout() string {
	if m != nil {
		return m.Stdout
	}
	return ""
}

func (m *DockerExecutor) GetStderr() string {
	if m != nil {
		return m.Stderr
	}
	return ""
}

// Attached volume request.
type Volume struct {
	// OPTIONAL
	// Name of attached volume
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// REQUIRED
	// Minimum size
	SizeGb float64 `protobuf:"fixed64,2,opt,name=sizeGb" json:"sizeGb,omitempty"`
	// OPTIONAL
	// Source volume, this would refer to an existing volume the execution engine
	// could identify. Leave blank if is to be a newly created volume
	// Volumes loaded from a source will be mounted as read only
	Source string `protobuf:"bytes,3,opt,name=source" json:"source,omitempty"`
	// REQUIRED
	// mount point for volume inside the docker container
	MountPoint string `protobuf:"bytes,6,opt,name=mountPoint" json:"mountPoint,omitempty"`
	// OPTIONAL default False
	Readonly bool `protobuf:"varint,7,opt,name=readonly" json:"readonly,omitempty"`
}

func (m *Volume) Reset()                    { *m = Volume{} }
func (m *Volume) String() string            { return proto.CompactTextString(m) }
func (*Volume) ProtoMessage()               {}
func (*Volume) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Volume) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Volume) GetSizeGb() float64 {
	if m != nil {
		return m.SizeGb
	}
	return 0
}

func (m *Volume) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *Volume) GetMountPoint() string {
	if m != nil {
		return m.MountPoint
	}
	return ""
}

func (m *Volume) GetReadonly() bool {
	if m != nil {
		return m.Readonly
	}
	return false
}

type Resources struct {
	// OPTIONAL default 1
	// Minimum number of CPUs
	MinimumCpuCores uint32 `protobuf:"varint,1,opt,name=minimumCpuCores" json:"minimumCpuCores,omitempty"`
	// Can schedule on resource that resource that can be preempted, like AWS Spot Instances
	// OPTIONAL default false
	Preemptible bool `protobuf:"varint,2,opt,name=preemptible" json:"preemptible,omitempty"`
	// REQUIRED
	// Minimum RAM required
	MinimumRamGb float64 `protobuf:"fixed64,3,opt,name=minimumRamGb" json:"minimumRamGb,omitempty"`
	// REQUIRED
	// Volumes to be mounted into the docker container
	Volumes []*Volume `protobuf:"bytes,4,rep,name=volumes" json:"volumes,omitempty"`
	// OPTIONAL
	// optional scheduling information for systems where multiple compute zones are avalible
	Zones []string `protobuf:"bytes,5,rep,name=zones" json:"zones,omitempty"`
}

func (m *Resources) Reset()                    { *m = Resources{} }
func (m *Resources) String() string            { return proto.CompactTextString(m) }
func (*Resources) ProtoMessage()               {}
func (*Resources) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Resources) GetMinimumCpuCores() uint32 {
	if m != nil {
		return m.MinimumCpuCores
	}
	return 0
}

func (m *Resources) GetPreemptible() bool {
	if m != nil {
		return m.Preemptible
	}
	return false
}

func (m *Resources) GetMinimumRamGb() float64 {
	if m != nil {
		return m.MinimumRamGb
	}
	return 0
}

func (m *Resources) GetVolumes() []*Volume {
	if m != nil {
		return m.Volumes
	}
	return nil
}

func (m *Resources) GetZones() []string {
	if m != nil {
		return m.Zones
	}
	return nil
}

// The description of a task to be run
type Task struct {
	// OPTIONAL
	// user name for task
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// OPTIONAL
	// parameter for execution engine to define/store group information
	ProjectID string `protobuf:"bytes,2,opt,name=projectID" json:"projectID,omitempty"`
	// OPTIONAL
	// free text description of task
	Description string `protobuf:"bytes,3,opt,name=description" json:"description,omitempty"`
	// REQUIRED
	// Files to be copied into system before tasks
	Inputs []*TaskParameter `protobuf:"bytes,4,rep,name=inputs" json:"inputs,omitempty"`
	// REQUIRED
	// Files to be copied out of the system after tasks
	Outputs []*TaskParameter `protobuf:"bytes,5,rep,name=outputs" json:"outputs,omitempty"`
	// REQUIRED
	// Define required system resources to run job
	Resources *Resources `protobuf:"bytes,6,opt,name=resources" json:"resources,omitempty"`
	// REQUIRED
	// An array of docker executions that will be run sequentially
	Docker []*DockerExecutor `protobuf:"bytes,8,rep,name=docker" json:"docker,omitempty"`
}

func (m *Task) Reset()                    { *m = Task{} }
func (m *Task) String() string            { return proto.CompactTextString(m) }
func (*Task) ProtoMessage()               {}
func (*Task) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Task) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Task) GetProjectID() string {
	if m != nil {
		return m.ProjectID
	}
	return ""
}

func (m *Task) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Task) GetInputs() []*TaskParameter {
	if m != nil {
		return m.Inputs
	}
	return nil
}

func (m *Task) GetOutputs() []*TaskParameter {
	if m != nil {
		return m.Outputs
	}
	return nil
}

func (m *Task) GetResources() *Resources {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *Task) GetDocker() []*DockerExecutor {
	if m != nil {
		return m.Docker
	}
	return nil
}

// Request listing of jobs tracked by server
type JobListRequest struct {
	// OPTIONAL
	// The name of the project to search for pipelines. Caller must have READ access to this project.
	ProjectID string `protobuf:"bytes,1,opt,name=projectID" json:"projectID,omitempty"`
	// OPTIONAL
	// Pipelines with names that match this prefix should be returned. If unspecified, all pipelines in the project, up to pageSize, will be returned.
	NamePrefix string `protobuf:"bytes,2,opt,name=namePrefix" json:"namePrefix,omitempty"`
	// OPTIONAL
	// Number of pipelines to return at once. Defaults to 256, and max is 2048.
	PageSize uint32 `protobuf:"varint,3,opt,name=pageSize" json:"pageSize,omitempty"`
	// OPTIONAL
	// Token to use to indicate where to start getting results. If unspecified, returns the first page of results.
	PageToken string `protobuf:"bytes,4,opt,name=pageToken" json:"pageToken,omitempty"`
}

func (m *JobListRequest) Reset()                    { *m = JobListRequest{} }
func (m *JobListRequest) String() string            { return proto.CompactTextString(m) }
func (*JobListRequest) ProtoMessage()               {}
func (*JobListRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *JobListRequest) GetProjectID() string {
	if m != nil {
		return m.ProjectID
	}
	return ""
}

func (m *JobListRequest) GetNamePrefix() string {
	if m != nil {
		return m.NamePrefix
	}
	return ""
}

func (m *JobListRequest) GetPageSize() uint32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *JobListRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

// Small description of tasks, returned by server during listing
type TaskDesc struct {
	Name        string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	ProjectID   string `protobuf:"bytes,2,opt,name=projectID" json:"projectID,omitempty"`
	Description string `protobuf:"bytes,3,opt,name=description" json:"description,omitempty"`
}

func (m *TaskDesc) Reset()                    { *m = TaskDesc{} }
func (m *TaskDesc) String() string            { return proto.CompactTextString(m) }
func (*TaskDesc) ProtoMessage()               {}
func (*TaskDesc) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *TaskDesc) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TaskDesc) GetProjectID() string {
	if m != nil {
		return m.ProjectID
	}
	return ""
}

func (m *TaskDesc) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// Small description of jobs, returned by server during listing
type JobDesc struct {
	// REQUIRED
	JobID string `protobuf:"bytes,1,opt,name=jobID" json:"jobID,omitempty"`
	// REQUIRED
	State State     `protobuf:"varint,2,opt,name=state,enum=ga4gh_task_exec.State" json:"state,omitempty"`
	Task  *TaskDesc `protobuf:"bytes,3,opt,name=task" json:"task,omitempty"`
}

func (m *JobDesc) Reset()                    { *m = JobDesc{} }
func (m *JobDesc) String() string            { return proto.CompactTextString(m) }
func (*JobDesc) ProtoMessage()               {}
func (*JobDesc) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *JobDesc) GetJobID() string {
	if m != nil {
		return m.JobID
	}
	return ""
}

func (m *JobDesc) GetState() State {
	if m != nil {
		return m.State
	}
	return State_Unknown
}

func (m *JobDesc) GetTask() *TaskDesc {
	if m != nil {
		return m.Task
	}
	return nil
}

// Return envelope
type JobListResponse struct {
	Jobs          []*JobDesc `protobuf:"bytes,1,rep,name=jobs" json:"jobs,omitempty"`
	NextPageToken string     `protobuf:"bytes,2,opt,name=nextPageToken" json:"nextPageToken,omitempty"`
}

func (m *JobListResponse) Reset()                    { *m = JobListResponse{} }
func (m *JobListResponse) String() string            { return proto.CompactTextString(m) }
func (*JobListResponse) ProtoMessage()               {}
func (*JobListResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *JobListResponse) GetJobs() []*JobDesc {
	if m != nil {
		return m.Jobs
	}
	return nil
}

func (m *JobListResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

// ID of an instance of a Task
type JobID struct {
	Value string `protobuf:"bytes,1,opt,name=value" json:"value,omitempty"`
}

func (m *JobID) Reset()                    { *m = JobID{} }
func (m *JobID) String() string            { return proto.CompactTextString(m) }
func (*JobID) ProtoMessage()               {}
func (*JobID) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *JobID) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type JobLog struct {
	// The command line that was run
	Cmd []string `protobuf:"bytes,1,rep,name=cmd" json:"cmd,omitempty"`
	// When the command was executed
	StartTime string `protobuf:"bytes,2,opt,name=startTime" json:"startTime,omitempty"`
	// When the command completed
	EndTime string `protobuf:"bytes,3,opt,name=endTime" json:"endTime,omitempty"`
	// Sample of stdout (not guaranteed to be entire log)
	Stdout string `protobuf:"bytes,4,opt,name=stdout" json:"stdout,omitempty"`
	// Sample of stderr (not guaranteed to be entire log)
	Stderr string `protobuf:"bytes,5,opt,name=stderr" json:"stderr,omitempty"`
	// Exit code of the program
	ExitCode int32 `protobuf:"varint,6,opt,name=exitCode" json:"exitCode,omitempty"`
}

func (m *JobLog) Reset()                    { *m = JobLog{} }
func (m *JobLog) String() string            { return proto.CompactTextString(m) }
func (*JobLog) ProtoMessage()               {}
func (*JobLog) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *JobLog) GetCmd() []string {
	if m != nil {
		return m.Cmd
	}
	return nil
}

func (m *JobLog) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *JobLog) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

func (m *JobLog) GetStdout() string {
	if m != nil {
		return m.Stdout
	}
	return ""
}

func (m *JobLog) GetStderr() string {
	if m != nil {
		return m.Stderr
	}
	return ""
}

func (m *JobLog) GetExitCode() int32 {
	if m != nil {
		return m.ExitCode
	}
	return 0
}

// The description of the running instance of a task
type Job struct {
	JobID    string            `protobuf:"bytes,1,opt,name=jobID" json:"jobID,omitempty"`
	Metadata map[string]string `protobuf:"bytes,2,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Task     *Task             `protobuf:"bytes,3,opt,name=task" json:"task,omitempty"`
	State    State             `protobuf:"varint,4,opt,name=state,enum=ga4gh_task_exec.State" json:"state,omitempty"`
	Logs     []*JobLog         `protobuf:"bytes,5,rep,name=logs" json:"logs,omitempty"`
}

func (m *Job) Reset()                    { *m = Job{} }
func (m *Job) String() string            { return proto.CompactTextString(m) }
func (*Job) ProtoMessage()               {}
func (*Job) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *Job) GetJobID() string {
	if m != nil {
		return m.JobID
	}
	return ""
}

func (m *Job) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Job) GetTask() *Task {
	if m != nil {
		return m.Task
	}
	return nil
}

func (m *Job) GetState() State {
	if m != nil {
		return m.State
	}
	return State_Unknown
}

func (m *Job) GetLogs() []*JobLog {
	if m != nil {
		return m.Logs
	}
	return nil
}

// Blank request message for service request
type ServiceInfoRequest struct {
}

func (m *ServiceInfoRequest) Reset()                    { *m = ServiceInfoRequest{} }
func (m *ServiceInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*ServiceInfoRequest) ProtoMessage()               {}
func (*ServiceInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

// Information about Task Execution Service
// May include information related (but not limited to)
// resource availability and storage system information
type ServiceInfo struct {
	// System specific key/value pairs
	// Example for a shared file system based storage system:
	// storageType=sharedFile, baseDir=/path/to/shared/directory
	StorageConfig map[string]string `protobuf:"bytes,1,rep,name=storageConfig" json:"storageConfig,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *ServiceInfo) Reset()                    { *m = ServiceInfo{} }
func (m *ServiceInfo) String() string            { return proto.CompactTextString(m) }
func (*ServiceInfo) ProtoMessage()               {}
func (*ServiceInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *ServiceInfo) GetStorageConfig() map[string]string {
	if m != nil {
		return m.StorageConfig
	}
	return nil
}

func init() {
	proto.RegisterType((*TaskParameter)(nil), "ga4gh_task_exec.TaskParameter")
	proto.RegisterType((*DockerExecutor)(nil), "ga4gh_task_exec.DockerExecutor")
	proto.RegisterType((*Volume)(nil), "ga4gh_task_exec.Volume")
	proto.RegisterType((*Resources)(nil), "ga4gh_task_exec.Resources")
	proto.RegisterType((*Task)(nil), "ga4gh_task_exec.Task")
	proto.RegisterType((*JobListRequest)(nil), "ga4gh_task_exec.JobListRequest")
	proto.RegisterType((*TaskDesc)(nil), "ga4gh_task_exec.TaskDesc")
	proto.RegisterType((*JobDesc)(nil), "ga4gh_task_exec.JobDesc")
	proto.RegisterType((*JobListResponse)(nil), "ga4gh_task_exec.JobListResponse")
	proto.RegisterType((*JobID)(nil), "ga4gh_task_exec.JobID")
	proto.RegisterType((*JobLog)(nil), "ga4gh_task_exec.JobLog")
	proto.RegisterType((*Job)(nil), "ga4gh_task_exec.Job")
	proto.RegisterType((*ServiceInfoRequest)(nil), "ga4gh_task_exec.ServiceInfoRequest")
	proto.RegisterType((*ServiceInfo)(nil), "ga4gh_task_exec.ServiceInfo")
	proto.RegisterEnum("ga4gh_task_exec.State", State_name, State_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for TaskService service

type TaskServiceClient interface {
	// Get Service Info
	GetServiceInfo(ctx context.Context, in *ServiceInfoRequest, opts ...grpc.CallOption) (*ServiceInfo, error)
	// Run a task
	RunTask(ctx context.Context, in *Task, opts ...grpc.CallOption) (*JobID, error)
	// List the TaskOps
	ListJobs(ctx context.Context, in *JobListRequest, opts ...grpc.CallOption) (*JobListResponse, error)
	// Get info about a running task
	GetJob(ctx context.Context, in *JobID, opts ...grpc.CallOption) (*Job, error)
	// Cancel a running task
	CancelJob(ctx context.Context, in *JobID, opts ...grpc.CallOption) (*JobID, error)
}

type taskServiceClient struct {
	cc *grpc.ClientConn
}

func NewTaskServiceClient(cc *grpc.ClientConn) TaskServiceClient {
	return &taskServiceClient{cc}
}

func (c *taskServiceClient) GetServiceInfo(ctx context.Context, in *ServiceInfoRequest, opts ...grpc.CallOption) (*ServiceInfo, error) {
	out := new(ServiceInfo)
	err := grpc.Invoke(ctx, "/ga4gh_task_exec.TaskService/GetServiceInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) RunTask(ctx context.Context, in *Task, opts ...grpc.CallOption) (*JobID, error) {
	out := new(JobID)
	err := grpc.Invoke(ctx, "/ga4gh_task_exec.TaskService/RunTask", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) ListJobs(ctx context.Context, in *JobListRequest, opts ...grpc.CallOption) (*JobListResponse, error) {
	out := new(JobListResponse)
	err := grpc.Invoke(ctx, "/ga4gh_task_exec.TaskService/ListJobs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) GetJob(ctx context.Context, in *JobID, opts ...grpc.CallOption) (*Job, error) {
	out := new(Job)
	err := grpc.Invoke(ctx, "/ga4gh_task_exec.TaskService/GetJob", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) CancelJob(ctx context.Context, in *JobID, opts ...grpc.CallOption) (*JobID, error) {
	out := new(JobID)
	err := grpc.Invoke(ctx, "/ga4gh_task_exec.TaskService/CancelJob", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for TaskService service

type TaskServiceServer interface {
	// Get Service Info
	GetServiceInfo(context.Context, *ServiceInfoRequest) (*ServiceInfo, error)
	// Run a task
	RunTask(context.Context, *Task) (*JobID, error)
	// List the TaskOps
	ListJobs(context.Context, *JobListRequest) (*JobListResponse, error)
	// Get info about a running task
	GetJob(context.Context, *JobID) (*Job, error)
	// Cancel a running task
	CancelJob(context.Context, *JobID) (*JobID, error)
}

func RegisterTaskServiceServer(s *grpc.Server, srv TaskServiceServer) {
	s.RegisterService(&_TaskService_serviceDesc, srv)
}

func _TaskService_GetServiceInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServiceInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).GetServiceInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ga4gh_task_exec.TaskService/GetServiceInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).GetServiceInfo(ctx, req.(*ServiceInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_RunTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Task)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).RunTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ga4gh_task_exec.TaskService/RunTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).RunTask(ctx, req.(*Task))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_ListJobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).ListJobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ga4gh_task_exec.TaskService/ListJobs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).ListJobs(ctx, req.(*JobListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_GetJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).GetJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ga4gh_task_exec.TaskService/GetJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).GetJob(ctx, req.(*JobID))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_CancelJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JobID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).CancelJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ga4gh_task_exec.TaskService/CancelJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).CancelJob(ctx, req.(*JobID))
	}
	return interceptor(ctx, in, info, handler)
}

var _TaskService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ga4gh_task_exec.TaskService",
	HandlerType: (*TaskServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetServiceInfo",
			Handler:    _TaskService_GetServiceInfo_Handler,
		},
		{
			MethodName: "RunTask",
			Handler:    _TaskService_RunTask_Handler,
		},
		{
			MethodName: "ListJobs",
			Handler:    _TaskService_ListJobs_Handler,
		},
		{
			MethodName: "GetJob",
			Handler:    _TaskService_GetJob_Handler,
		},
		{
			MethodName: "CancelJob",
			Handler:    _TaskService_CancelJob_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "task_execution.proto",
}

func init() { proto.RegisterFile("task_execution.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1131 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xb4, 0x56, 0xcd, 0x6e, 0x23, 0x45,
	0x10, 0x66, 0xfc, 0xef, 0xf2, 0x3a, 0xb1, 0x1a, 0xb3, 0x3b, 0x58, 0x21, 0x6b, 0x0d, 0x1c, 0x42,
	0xd8, 0x8d, 0xb5, 0x06, 0x41, 0xb4, 0x48, 0x08, 0x29, 0x89, 0xa2, 0x44, 0xbb, 0xc8, 0x4c, 0x12,
	0x8e, 0x44, 0xed, 0x99, 0xca, 0xec, 0xc4, 0x9e, 0xee, 0xd9, 0x9e, 0x9e, 0x6c, 0x12, 0xe0, 0xc2,
	0x89, 0x3b, 0xf7, 0x15, 0x12, 0x12, 0xaf, 0xc1, 0x85, 0x37, 0x40, 0xbc, 0x01, 0x0f, 0x82, 0xba,
	0xa7, 0x3d, 0xb6, 0x63, 0x27, 0xda, 0x3d, 0x70, 0x9b, 0xaa, 0xae, 0xaa, 0xfe, 0xfa, 0xfb, 0xaa,
	0xca, 0x86, 0xb6, 0xa4, 0xc9, 0xe8, 0x14, 0x2f, 0xd1, 0x4b, 0x65, 0xc8, 0xd9, 0x56, 0x2c, 0xb8,
	0xe4, 0x64, 0x35, 0xa0, 0x9f, 0x05, 0x2f, 0x4e, 0xf3, 0xb3, 0xce, 0x5a, 0xc0, 0x79, 0x30, 0xc6,
	0x1e, 0x8d, 0xc3, 0x1e, 0x65, 0x8c, 0x4b, 0xaa, 0xa2, 0x93, 0x2c, 0xdc, 0xf9, 0xdd, 0x82, 0xe6,
	0x31, 0x4d, 0x46, 0x03, 0x2a, 0x68, 0x84, 0x12, 0x05, 0x21, 0x50, 0x62, 0x34, 0x42, 0xdb, 0xea,
	0x5a, 0x1b, 0x75, 0x57, 0x7f, 0x93, 0x2e, 0x34, 0x7c, 0x4c, 0x3c, 0x11, 0xc6, 0x2a, 0xd7, 0x2e,
	0xe8, 0xa3, 0x59, 0x17, 0xe9, 0x40, 0x6d, 0xcc, 0x3d, 0x5d, 0xda, 0x2e, 0xea, 0xe3, 0xdc, 0x56,
	0x15, 0x63, 0x2a, 0x5f, 0xd8, 0xa5, 0xac, 0xa2, 0xfa, 0x26, 0x6d, 0x28, 0x7b, 0x63, 0x9a, 0x24,
	0x76, 0x59, 0x3b, 0x33, 0x83, 0xdc, 0x87, 0x8a, 0x27, 0x90, 0x4a, 0xb4, 0x2b, 0x5d, 0x6b, 0xa3,
	0xe6, 0x1a, 0xcb, 0xf9, 0xcd, 0x82, 0x95, 0x5d, 0xee, 0x8d, 0x50, 0xec, 0xe9, 0xe7, 0x72, 0x41,
	0xd6, 0xa0, 0x1e, 0x46, 0x34, 0xc0, 0x6f, 0xa6, 0x58, 0xa7, 0x0e, 0xd2, 0x82, 0xa2, 0x17, 0xf9,
	0x76, 0xa1, 0x5b, 0xdc, 0xa8, 0xbb, 0xea, 0x93, 0xd8, 0x50, 0x7d, 0xc5, 0xc5, 0xc8, 0x0f, 0x85,
	0xc1, 0x37, 0x31, 0x15, 0x94, 0x44, 0xfa, 0x21, 0xd3, 0x77, 0xd6, 0xdd, 0xcc, 0x50, 0x50, 0x12,
	0xe9, 0xf3, 0x54, 0x1a, 0xd8, 0xc6, 0x32, 0x7e, 0x14, 0xc2, 0x20, 0x37, 0x96, 0xf3, 0x8b, 0x05,
	0x95, 0xef, 0xf8, 0x38, 0x8d, 0x70, 0x29, 0x83, 0x2a, 0x2d, 0xbc, 0xc6, 0xfd, 0xa1, 0x26, 0xcf,
	0x72, 0x8d, 0xa5, 0xfd, 0x3c, 0x15, 0x1e, 0x1a, 0x54, 0xc6, 0x22, 0xeb, 0x00, 0x11, 0x4f, 0x99,
	0x1c, 0xf0, 0x90, 0x49, 0x83, 0x6c, 0xc6, 0xa3, 0xf8, 0x16, 0x48, 0x7d, 0xce, 0xc6, 0x57, 0x76,
	0x55, 0x73, 0x95, 0xdb, 0xce, 0x5f, 0x16, 0xd4, 0x5d, 0xcc, 0x0a, 0x25, 0x64, 0x03, 0x56, 0xa3,
	0x90, 0x85, 0x51, 0x1a, 0xed, 0xc4, 0xe9, 0x0e, 0x17, 0x98, 0x68, 0x60, 0x4d, 0xf7, 0xa6, 0x5b,
	0xa9, 0x1c, 0x0b, 0xc4, 0x28, 0x96, 0xe1, 0x70, 0x8c, 0x1a, 0x68, 0xcd, 0x9d, 0x75, 0x11, 0x07,
	0xee, 0x99, 0x24, 0x97, 0x46, 0xfb, 0x43, 0x8d, 0xd9, 0x72, 0xe7, 0x7c, 0xe4, 0x09, 0x54, 0x2f,
	0x34, 0x0f, 0x89, 0x5d, 0xea, 0x16, 0x37, 0x1a, 0xfd, 0x07, 0x5b, 0x37, 0x5a, 0x72, 0x2b, 0xe3,
	0xc9, 0x9d, 0xc4, 0x29, 0x05, 0xae, 0x39, 0x43, 0xd5, 0x0c, 0x4a, 0xaf, 0xcc, 0x70, 0xfe, 0x2c,
	0x40, 0x49, 0xb5, 0xe6, 0x52, 0x3e, 0xd7, 0xa0, 0x1e, 0x0b, 0x7e, 0x8e, 0x9e, 0x3c, 0xd8, 0x35,
	0xfd, 0x38, 0x75, 0xdc, 0xec, 0xd7, 0xe2, 0x62, 0xbf, 0x7e, 0x0e, 0x95, 0x90, 0xc5, 0xa9, 0x9c,
	0x80, 0x5c, 0x5f, 0x00, 0x39, 0x37, 0x15, 0xae, 0x89, 0x26, 0xdb, 0x50, 0xe5, 0xa9, 0xd4, 0x89,
	0xe5, 0x37, 0x4a, 0x9c, 0x84, 0x93, 0x6d, 0xa8, 0x8b, 0x89, 0x28, 0x5a, 0xd0, 0x46, 0xbf, 0xb3,
	0x90, 0x9b, 0xcb, 0xe6, 0x4e, 0x83, 0xc9, 0x17, 0x50, 0xf1, 0x75, 0xf3, 0xdb, 0x35, 0x7d, 0xe5,
	0xc3, 0x85, 0xb4, 0xf9, 0xd9, 0x70, 0x4d, 0xb8, 0xea, 0xc9, 0x95, 0x43, 0x3e, 0x7c, 0x16, 0x26,
	0xd2, 0xc5, 0x97, 0x29, 0x26, 0x72, 0x9e, 0x37, 0xeb, 0x26, 0x6f, 0xeb, 0x00, 0x8a, 0xdd, 0x81,
	0xc0, 0xb3, 0xf0, 0xd2, 0xd0, 0x3a, 0xe3, 0x51, 0x5d, 0x17, 0xd3, 0x00, 0x8f, 0xc2, 0xeb, 0xac,
	0x5f, 0x9b, 0x6e, 0x6e, 0xeb, 0xca, 0x34, 0xc0, 0x63, 0x3e, 0x42, 0x66, 0x66, 0x66, 0xea, 0x70,
	0xbe, 0x87, 0x9a, 0xe2, 0x65, 0x17, 0x13, 0xef, 0xff, 0xd0, 0xd3, 0xf9, 0x11, 0xaa, 0x87, 0x7c,
	0xa8, 0xcb, 0xb7, 0xa1, 0x7c, 0xce, 0x87, 0xf9, 0xf3, 0x32, 0x83, 0x3c, 0x52, 0x53, 0xae, 0x36,
	0x8b, 0x2a, 0xbe, 0xd2, 0xbf, 0xbf, 0xc0, 0xe1, 0x91, 0x3a, 0x75, 0xb3, 0x20, 0xf2, 0x18, 0x4a,
	0xea, 0x44, 0xdf, 0xd4, 0xe8, 0xbf, 0xbf, 0x54, 0x63, 0x75, 0x99, 0xab, 0xc3, 0x1c, 0x84, 0xd5,
	0x9c, 0xe7, 0x24, 0xe6, 0x2c, 0x41, 0xf2, 0x08, 0x4a, 0xe7, 0x7c, 0xa8, 0x66, 0x4d, 0x49, 0x66,
	0x2f, 0x54, 0x30, 0x68, 0x5d, 0x1d, 0x45, 0x3e, 0x82, 0x26, 0xc3, 0x4b, 0x39, 0xc8, 0x09, 0xcc,
	0x28, 0x98, 0x77, 0x3a, 0x1f, 0x40, 0xf9, 0x50, 0x3f, 0xa6, 0x0d, 0xe5, 0x0b, 0x3a, 0x4e, 0x27,
	0x14, 0x66, 0x86, 0xf3, 0xda, 0x82, 0x8a, 0x82, 0xc1, 0x83, 0xc9, 0xfe, 0xb3, 0xa6, 0xfb, 0x6f,
	0x0d, 0xea, 0x89, 0xa4, 0x42, 0x1e, 0x87, 0x11, 0x4e, 0x08, 0xce, 0x1d, 0x6a, 0x3b, 0x22, 0xf3,
	0xf5, 0x99, 0xd9, 0x8e, 0xc6, 0x7c, 0xdb, 0x3d, 0xa8, 0x5a, 0x04, 0x2f, 0x43, 0xb9, 0xc3, 0xfd,
	0x6c, 0x89, 0x97, 0xdd, 0xdc, 0x76, 0x5e, 0x17, 0xa0, 0x78, 0xc8, 0x87, 0xb7, 0x28, 0xf4, 0x15,
	0xd4, 0x22, 0x94, 0xd4, 0xa7, 0x92, 0xea, 0xc5, 0xdd, 0xe8, 0x3b, 0xcb, 0x58, 0xdb, 0x7a, 0x6e,
	0x82, 0xf6, 0x98, 0x14, 0x57, 0x6e, 0x9e, 0x43, 0x3e, 0x9e, 0xd3, 0xec, 0xbd, 0xa5, 0x9a, 0x65,
	0x7a, 0x4d, 0x9b, 0xa1, 0xf4, 0x26, 0xcd, 0xf0, 0x09, 0x94, 0xc6, 0x3c, 0x98, 0x0c, 0xfc, 0x83,
	0x65, 0xa0, 0x9e, 0xf1, 0xc0, 0xd5, 0x41, 0x9d, 0x2f, 0xa1, 0x39, 0x07, 0x50, 0x49, 0x31, 0xc2,
	0x2b, 0xf3, 0x54, 0xf5, 0x39, 0x55, 0xaf, 0x30, 0xa3, 0xde, 0xd3, 0xc2, 0xb6, 0xe5, 0xb4, 0x81,
	0x1c, 0xa1, 0xb8, 0x08, 0x3d, 0x3c, 0x60, 0x67, 0xdc, 0xcc, 0xac, 0xf3, 0x87, 0x05, 0x8d, 0x19,
	0x37, 0x39, 0x81, 0x66, 0x22, 0xb9, 0xa0, 0x01, 0xee, 0x70, 0x76, 0x16, 0x06, 0xa6, 0xc7, 0x7a,
	0x8b, 0xaf, 0x98, 0x26, 0x6d, 0x1d, 0xcd, 0x66, 0x64, 0xd4, 0xcd, 0x57, 0xe9, 0x7c, 0x0d, 0x64,
	0x31, 0xe8, 0x6d, 0xe0, 0x6f, 0xbe, 0x84, 0xb2, 0x26, 0x8e, 0x34, 0xa0, 0x7a, 0xc2, 0x46, 0x8c,
	0xbf, 0x62, 0xad, 0x77, 0x08, 0x40, 0xe5, 0xdb, 0x14, 0x53, 0xf4, 0x5b, 0x96, 0x3a, 0x70, 0x53,
	0xc6, 0x42, 0x16, 0xb4, 0x0a, 0xea, 0x60, 0x40, 0xd3, 0x04, 0xfd, 0x56, 0x91, 0xdc, 0x83, 0xda,
	0x0e, 0x8f, 0xe2, 0x31, 0x4a, 0x6c, 0x95, 0x48, 0x1d, 0xca, 0x7b, 0x42, 0x70, 0xd1, 0x2a, 0x93,
	0x55, 0x68, 0x1c, 0x5d, 0x25, 0x12, 0xa3, 0xcc, 0x51, 0xd1, 0x91, 0x94, 0x79, 0x38, 0x46, 0xbf,
	0x55, 0xed, 0xff, 0x53, 0x84, 0x86, 0x12, 0xd6, 0x3c, 0x95, 0x44, 0xb0, 0xb2, 0x8f, 0x72, 0x96,
	0xad, 0x0f, 0xef, 0xa2, 0xc5, 0x50, 0xdc, 0x59, 0xbb, 0x2b, 0xc8, 0xb1, 0x7f, 0xfe, 0xfb, 0xdf,
	0x5f, 0x0b, 0x84, 0xb4, 0x7a, 0x17, 0x4f, 0x7a, 0x6a, 0x5e, 0x1f, 0x27, 0xe6, 0xba, 0xe7, 0xfa,
	0x3d, 0xfa, 0x57, 0x6a, 0x79, 0xc3, 0x75, 0xee, 0x2f, 0x6b, 0x97, 0x83, 0x5d, 0xe7, 0x5d, 0x5d,
	0xb3, 0xe9, 0xd4, 0x26, 0x35, 0x9f, 0x5a, 0x9b, 0xe4, 0x14, 0x6a, 0x6a, 0x89, 0x1c, 0xaa, 0x95,
	0xf0, 0x70, 0x69, 0x9f, 0x4d, 0x57, 0x79, 0xa7, 0x7b, 0x7b, 0x40, 0xb6, 0x83, 0x9c, 0x96, 0xbe,
	0x03, 0x48, 0x7e, 0x07, 0x19, 0x40, 0x65, 0x1f, 0x55, 0x7d, 0x72, 0x0b, 0xae, 0x4e, 0x7b, 0x99,
	0x7f, 0x91, 0x81, 0xde, 0x0f, 0x5a, 0xf6, 0x9f, 0xc8, 0x09, 0xd4, 0x33, 0x39, 0xee, 0x2a, 0x7a,
	0x1b, 0x09, 0xa6, 0xec, 0xe6, 0x42, 0xd9, 0x61, 0x45, 0xff, 0x3d, 0xfd, 0xf4, 0xbf, 0x00, 0x00,
	0x00, 0xff, 0xff, 0x57, 0x20, 0x74, 0xf5, 0xe5, 0x0a, 0x00, 0x00,
}
