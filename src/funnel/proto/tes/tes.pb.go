// Code generated by protoc-gen-go.
// source: tes.proto
// DO NOT EDIT!

/*
Package tes is a generated protocol buffer package.

It is generated from these files:
	tes.proto

It has these top-level messages:
	CreateTaskRequest
	TaskParameter
	Ports
	Executor
	Resources
	GetTaskRequest
	Task
	TaskLog
	ExecutorLog
	OutputFileLog
	ListTasksRequest
	ListTasksResponse
	TaskDesc
	CancelTaskRequest
	CancelTaskResponse
	ServiceInfoRequest
	ServiceInfo
*/
package tes

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/grpc-ecosystem/grpc-gateway/third_party/googleapis/google/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type FileType int32

const (
	FileType_FILE      FileType = 0
	FileType_DIRECTORY FileType = 1
)

var FileType_name = map[int32]string{
	0: "FILE",
	1: "DIRECTORY",
}
var FileType_value = map[string]int32{
	"FILE":      0,
	"DIRECTORY": 1,
}

func (x FileType) String() string {
	return proto.EnumName(FileType_name, int32(x))
}
func (FileType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// OUTPUT ONLY
//
// Task states.
type State int32

const (
	State_UNKNOWN      State = 0
	State_QUEUED       State = 1
	State_INITIALIZING State = 2
	State_RUNNING      State = 3
	// An implementation *may* have the ability to pause a task,
	// but this is not required.
	State_PAUSED       State = 4
	State_COMPLETE     State = 5
	State_ERROR        State = 6
	State_SYSTEM_ERROR State = 7
	State_CANCELED     State = 8
)

var State_name = map[int32]string{
	0: "UNKNOWN",
	1: "QUEUED",
	2: "INITIALIZING",
	3: "RUNNING",
	4: "PAUSED",
	5: "COMPLETE",
	6: "ERROR",
	7: "SYSTEM_ERROR",
	8: "CANCELED",
}
var State_value = map[string]int32{
	"UNKNOWN":      0,
	"QUEUED":       1,
	"INITIALIZING": 2,
	"RUNNING":      3,
	"PAUSED":       4,
	"COMPLETE":     5,
	"ERROR":        6,
	"SYSTEM_ERROR": 7,
	"CANCELED":     8,
}

func (x State) String() string {
	return proto.EnumName(State_name, int32(x))
}
func (State) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// CreateTaskRequest describes a task to be created and run.
type CreateTaskRequest struct {
	// OPTIONAL
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// OPTIONAL
	//
	// Describes the project this task is associated with.
	// Commonly used for billing on cloud providers (AWS, Google Cloud, etc).
	Project string `protobuf:"bytes,2,opt,name=project" json:"project,omitempty"`
	// OPTIONAL
	Description string `protobuf:"bytes,3,opt,name=description" json:"description,omitempty"`
	// OPTIONAL
	//
	// Input files.
	// Inputs will be downloaded and mounted into the executor container.
	Inputs []*TaskParameter `protobuf:"bytes,4,rep,name=inputs" json:"inputs,omitempty"`
	// OPTIONAL
	//
	// Output files.
	// Outputs will be uploaded from the executor container to long-term storage.
	Outputs []*TaskParameter `protobuf:"bytes,5,rep,name=outputs" json:"outputs,omitempty"`
	// OPTIONAL
	//
	// Request that the task be run with these resources.
	Resources *Resources `protobuf:"bytes,6,opt,name=resources" json:"resources,omitempty"`
	// REQUIRED
	//
	// A list of executors to be run, sequentially.
	Executors []*Executor `protobuf:"bytes,8,rep,name=executors" json:"executors,omitempty"`
	// OPTIONAL
	//
	// Declared volumes.
	// Volumes are shared between executors. Volumes for inputs and outputs are
	// inferred and should not be delcared here.
	Volumes []string `protobuf:"bytes,9,rep,name=volumes" json:"volumes,omitempty"`
	// OPTIONAL
	//
	// A key-value map of arbitrary tags.
	Tags map[string]string `protobuf:"bytes,10,rep,name=tags" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *CreateTaskRequest) Reset()                    { *m = CreateTaskRequest{} }
func (m *CreateTaskRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateTaskRequest) ProtoMessage()               {}
func (*CreateTaskRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *CreateTaskRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreateTaskRequest) GetProject() string {
	if m != nil {
		return m.Project
	}
	return ""
}

func (m *CreateTaskRequest) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *CreateTaskRequest) GetInputs() []*TaskParameter {
	if m != nil {
		return m.Inputs
	}
	return nil
}

func (m *CreateTaskRequest) GetOutputs() []*TaskParameter {
	if m != nil {
		return m.Outputs
	}
	return nil
}

func (m *CreateTaskRequest) GetResources() *Resources {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *CreateTaskRequest) GetExecutors() []*Executor {
	if m != nil {
		return m.Executors
	}
	return nil
}

func (m *CreateTaskRequest) GetVolumes() []string {
	if m != nil {
		return m.Volumes
	}
	return nil
}

func (m *CreateTaskRequest) GetTags() map[string]string {
	if m != nil {
		return m.Tags
	}
	return nil
}

// TaskParameter describes input and output files for a Task.
type TaskParameter struct {
	// OPTIONAL
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// OPTIONAL
	Description string `protobuf:"bytes,2,opt,name=description" json:"description,omitempty"`
	// REQUIRED
	//
	// URL in long term storage, for example:
	// s3://my-object-store/file1
	// gs://my-bucket/file2
	// file:///path/to/my/file
	// /path/to/my/file
	// etc...
	Url string `protobuf:"bytes,3,opt,name=url" json:"url,omitempty"`
	// REQUIRED
	//
	// Path of the file inside the container.
	Path string `protobuf:"bytes,4,opt,name=path" json:"path,omitempty"`
	// REQUIRED
	//
	// Type of the file, FILE or DIRECTORY
	Type FileType `protobuf:"varint,5,opt,name=type,enum=tes.FileType" json:"type,omitempty"`
	// OPTIONAL
	//
	// File contents literal.
	// Implementations should support a minimum of 128 KiB in this field and may define its own maximum.
	// UTF-8 encoded
	Contents string `protobuf:"bytes,6,opt,name=contents" json:"contents,omitempty"`
}

func (m *TaskParameter) Reset()                    { *m = TaskParameter{} }
func (m *TaskParameter) String() string            { return proto.CompactTextString(m) }
func (*TaskParameter) ProtoMessage()               {}
func (*TaskParameter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *TaskParameter) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TaskParameter) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *TaskParameter) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *TaskParameter) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *TaskParameter) GetType() FileType {
	if m != nil {
		return m.Type
	}
	return FileType_FILE
}

func (m *TaskParameter) GetContents() string {
	if m != nil {
		return m.Contents
	}
	return ""
}

// Ports describes the port mapping between the container and host.
type Ports struct {
	// REQUIRED
	//
	// Port number opened inside the container.
	Container uint32 `protobuf:"varint,1,opt,name=container" json:"container,omitempty"`
	// OPTIONAL
	//
	// Port number opened on the host. Must be greater than 1024.
	// Defaults to 0, which assigns a random port on the host.
	Host uint32 `protobuf:"varint,2,opt,name=host" json:"host,omitempty"`
}

func (m *Ports) Reset()                    { *m = Ports{} }
func (m *Ports) String() string            { return proto.CompactTextString(m) }
func (*Ports) ProtoMessage()               {}
func (*Ports) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Ports) GetContainer() uint32 {
	if m != nil {
		return m.Container
	}
	return 0
}

func (m *Ports) GetHost() uint32 {
	if m != nil {
		return m.Host
	}
	return 0
}

// Executor describes a command to run, and its environment.
type Executor struct {
	// REQUIRED
	//
	// Name of the container image, for example:
	// ubuntu
	// quay.io/aptible/ubuntu
	// gcr.io/my-org/my-image
	// etc...
	ImageName string `protobuf:"bytes,1,opt,name=image_name,json=imageName" json:"image_name,omitempty"`
	// REQUIRED
	//
	// The command to be executed.
	Cmd []string `protobuf:"bytes,2,rep,name=cmd" json:"cmd,omitempty"`
	// OPTIONAL
	//
	// The working directory that the command will be executed in.
	// Defaults to the directory set by the container image.
	Workdir string `protobuf:"bytes,3,opt,name=workdir" json:"workdir,omitempty"`
	// OPTIONAL
	//
	// Path inside the container to a file which will be piped
	// to the command's stdin.
	Stdin string `protobuf:"bytes,6,opt,name=stdin" json:"stdin,omitempty"`
	// OPTIONAL
	//
	// Path inside the container to a file where the command's
	// stdout will be written to.
	Stdout string `protobuf:"bytes,4,opt,name=stdout" json:"stdout,omitempty"`
	// OPTIONAL
	//
	// Path inside the container to a file where the command's
	// stderr will be written to.
	Stderr string `protobuf:"bytes,5,opt,name=stderr" json:"stderr,omitempty"`
	// OPTIONAL
	//
	// Port to expose from within the container, blank if none.
	Ports []*Ports `protobuf:"bytes,7,rep,name=ports" json:"ports,omitempty"`
	// OPTIONAL
	//
	// Enviromental variables to set within the container.
	Environ map[string]string `protobuf:"bytes,8,rep,name=environ" json:"environ,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Executor) Reset()                    { *m = Executor{} }
func (m *Executor) String() string            { return proto.CompactTextString(m) }
func (*Executor) ProtoMessage()               {}
func (*Executor) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Executor) GetImageName() string {
	if m != nil {
		return m.ImageName
	}
	return ""
}

func (m *Executor) GetCmd() []string {
	if m != nil {
		return m.Cmd
	}
	return nil
}

func (m *Executor) GetWorkdir() string {
	if m != nil {
		return m.Workdir
	}
	return ""
}

func (m *Executor) GetStdin() string {
	if m != nil {
		return m.Stdin
	}
	return ""
}

func (m *Executor) GetStdout() string {
	if m != nil {
		return m.Stdout
	}
	return ""
}

func (m *Executor) GetStderr() string {
	if m != nil {
		return m.Stderr
	}
	return ""
}

func (m *Executor) GetPorts() []*Ports {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *Executor) GetEnviron() map[string]string {
	if m != nil {
		return m.Environ
	}
	return nil
}

// Resources describes the resources requested by a task.
type Resources struct {
	// OPTIONAL
	//
	// Requested number of CPUs
	CpuCores uint32 `protobuf:"varint,1,opt,name=cpu_cores,json=cpuCores" json:"cpu_cores,omitempty"`
	// OPTIONAL
	//
	// Is the task allowed to run on preemptible compute instances (e.g. AWS Spot)?
	Preemptible bool `protobuf:"varint,2,opt,name=preemptible" json:"preemptible,omitempty"`
	// OPTIONAL
	//
	// Requested RAM required in gigabytes (GB)
	RamGb float64 `protobuf:"fixed64,3,opt,name=ram_gb,json=ramGb" json:"ram_gb,omitempty"`
	// OPTIONAL
	//
	// Requested disk size in gigabytes (GB)
	SizeGb float64 `protobuf:"fixed64,4,opt,name=size_gb,json=sizeGb" json:"size_gb,omitempty"`
	// OPTIONAL
	//
	// Request that the task be run in these compute zones.
	Zones []string `protobuf:"bytes,5,rep,name=zones" json:"zones,omitempty"`
}

func (m *Resources) Reset()                    { *m = Resources{} }
func (m *Resources) String() string            { return proto.CompactTextString(m) }
func (*Resources) ProtoMessage()               {}
func (*Resources) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Resources) GetCpuCores() uint32 {
	if m != nil {
		return m.CpuCores
	}
	return 0
}

func (m *Resources) GetPreemptible() bool {
	if m != nil {
		return m.Preemptible
	}
	return false
}

func (m *Resources) GetRamGb() float64 {
	if m != nil {
		return m.RamGb
	}
	return 0
}

func (m *Resources) GetSizeGb() float64 {
	if m != nil {
		return m.SizeGb
	}
	return 0
}

func (m *Resources) GetZones() []string {
	if m != nil {
		return m.Zones
	}
	return nil
}

// GetTaskRequest describes a request to the GetTask endpoint.
type GetTaskRequest struct {
	// REQUIRED
	//
	// Task identifier.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *GetTaskRequest) Reset()                    { *m = GetTaskRequest{} }
func (m *GetTaskRequest) String() string            { return proto.CompactTextString(m) }
func (*GetTaskRequest) ProtoMessage()               {}
func (*GetTaskRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *GetTaskRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// OUTPUT ONLY
//
// Task describes an instance of a task.
type Task struct {
	// REQUIRED
	//
	// Task identifier.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// REQUIRED
	Metadata map[string]string `protobuf:"bytes,2,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// REQUIRED
	Request *CreateTaskRequest `protobuf:"bytes,3,opt,name=request" json:"request,omitempty"`
	// REQUIRED
	State State `protobuf:"varint,4,opt,name=state,enum=tes.State" json:"state,omitempty"`
	// REQUIRED
	//
	// Task logging information.
	// Normally, this will contain only one entry, but in the case where
	// a task fails and is retried, an entry will be appended to this list.
	Logs []*TaskLog `protobuf:"bytes,5,rep,name=logs" json:"logs,omitempty"`
	// REQUIRED
	//
	// Information about all output files. Directory outputs are
	// flattened into separate items.
	Outputs []*OutputFileLog `protobuf:"bytes,6,rep,name=outputs" json:"outputs,omitempty"`
}

func (m *Task) Reset()                    { *m = Task{} }
func (m *Task) String() string            { return proto.CompactTextString(m) }
func (*Task) ProtoMessage()               {}
func (*Task) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Task) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Task) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Task) GetRequest() *CreateTaskRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *Task) GetState() State {
	if m != nil {
		return m.State
	}
	return State_UNKNOWN
}

func (m *Task) GetLogs() []*TaskLog {
	if m != nil {
		return m.Logs
	}
	return nil
}

func (m *Task) GetOutputs() []*OutputFileLog {
	if m != nil {
		return m.Outputs
	}
	return nil
}

// OUTPUT ONLY
//
// TaskLog describes logging information related to a Task.
type TaskLog struct {
	// REQUIRED
	//
	// Logs for each executor
	Logs []*ExecutorLog `protobuf:"bytes,1,rep,name=logs" json:"logs,omitempty"`
	// OPTIONAL
	//
	// Arbitrary logging metadata included by the implementation.
	Metadata map[string]string `protobuf:"bytes,2,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// OPTIONAL
	//
	// When the task started, in RFC 3339 format.
	StartTime string `protobuf:"bytes,3,opt,name=start_time,json=startTime" json:"start_time,omitempty"`
	// OPTIONAL
	//
	// When the task ended, in RFC 3339 format.
	EndTime string `protobuf:"bytes,4,opt,name=end_time,json=endTime" json:"end_time,omitempty"`
}

func (m *TaskLog) Reset()                    { *m = TaskLog{} }
func (m *TaskLog) String() string            { return proto.CompactTextString(m) }
func (*TaskLog) ProtoMessage()               {}
func (*TaskLog) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *TaskLog) GetLogs() []*ExecutorLog {
	if m != nil {
		return m.Logs
	}
	return nil
}

func (m *TaskLog) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *TaskLog) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *TaskLog) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

// OUTPUT ONLY
//
// ExecutorLog describes logging information related to an Executor.
type ExecutorLog struct {
	// OPTIONAL
	//
	// Time the executor started, in RFC 3339 format.
	StartTime string `protobuf:"bytes,2,opt,name=start_time,json=startTime" json:"start_time,omitempty"`
	// OPTIONAL
	//
	// Time the executor ended, in RFC 3339 format.
	EndTime string `protobuf:"bytes,3,opt,name=end_time,json=endTime" json:"end_time,omitempty"`
	// OPTIONAL
	//
	// Stdout tail.
	// This is not guaranteed to be the entire log.
	// Implementations determine the maximum size.
	Stdout string `protobuf:"bytes,4,opt,name=stdout" json:"stdout,omitempty"`
	// OPTIONAL
	//
	// Stderr tail.
	// This is not guaranteed to be the entire log.
	// Implementations determine the maximum size.
	Stderr string `protobuf:"bytes,5,opt,name=stderr" json:"stderr,omitempty"`
	// REQUIRED
	//
	// Exit code.
	ExitCode int32 `protobuf:"varint,6,opt,name=exit_code,json=exitCode" json:"exit_code,omitempty"`
	// OPTIONAL
	//
	// IP address of host.
	HostIp string `protobuf:"bytes,7,opt,name=host_ip,json=hostIp" json:"host_ip,omitempty"`
	// OPTIONAL
	//
	// Ports mapped between the container and host.
	Ports []*Ports `protobuf:"bytes,8,rep,name=ports" json:"ports,omitempty"`
}

func (m *ExecutorLog) Reset()                    { *m = ExecutorLog{} }
func (m *ExecutorLog) String() string            { return proto.CompactTextString(m) }
func (*ExecutorLog) ProtoMessage()               {}
func (*ExecutorLog) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *ExecutorLog) GetStartTime() string {
	if m != nil {
		return m.StartTime
	}
	return ""
}

func (m *ExecutorLog) GetEndTime() string {
	if m != nil {
		return m.EndTime
	}
	return ""
}

func (m *ExecutorLog) GetStdout() string {
	if m != nil {
		return m.Stdout
	}
	return ""
}

func (m *ExecutorLog) GetStderr() string {
	if m != nil {
		return m.Stderr
	}
	return ""
}

func (m *ExecutorLog) GetExitCode() int32 {
	if m != nil {
		return m.ExitCode
	}
	return 0
}

func (m *ExecutorLog) GetHostIp() string {
	if m != nil {
		return m.HostIp
	}
	return ""
}

func (m *ExecutorLog) GetPorts() []*Ports {
	if m != nil {
		return m.Ports
	}
	return nil
}

// OUTPUT ONLY
//
// OutputFileLog describes a single output file. This describes
// file details after the task has completed successfully,
// for logging purposes.
type OutputFileLog struct {
	// REQUIRED
	//
	// URL of the file in storage, e.g. s3://bucket/file.txt
	Url string `protobuf:"bytes,1,opt,name=url" json:"url,omitempty"`
	// REQUIRED
	//
	// Path of the file inside the container.
	Path string `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
	// REQUIRED
	//
	// Size of the file in bytes.
	SizeBytes int64 `protobuf:"varint,3,opt,name=size_bytes,json=sizeBytes" json:"size_bytes,omitempty"`
}

func (m *OutputFileLog) Reset()                    { *m = OutputFileLog{} }
func (m *OutputFileLog) String() string            { return proto.CompactTextString(m) }
func (*OutputFileLog) ProtoMessage()               {}
func (*OutputFileLog) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *OutputFileLog) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *OutputFileLog) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *OutputFileLog) GetSizeBytes() int64 {
	if m != nil {
		return m.SizeBytes
	}
	return 0
}

// ListTasksRequest describes a request to the ListTasks service endpoint.
type ListTasksRequest struct {
	// OPTIONAL
	//
	// Filter the task list to include tasks in this project.
	Project string `protobuf:"bytes,1,opt,name=project" json:"project,omitempty"`
	// OPTIONAL
	//
	// Filter the list to include tasks where the name matches this prefix.
	// If unspecified, no task name filtering is done.
	NamePrefix string `protobuf:"bytes,2,opt,name=name_prefix,json=namePrefix" json:"name_prefix,omitempty"`
	// OPTIONAL
	//
	// Number of tasks to return in one page.
	// Must be less than 2048. Defaults to 256.
	PageSize uint32 `protobuf:"varint,3,opt,name=page_size,json=pageSize" json:"page_size,omitempty"`
	// OPTIONAL
	//
	// Page token is used to retrieve the next page of results.
	// If unspecified, returns the first page of results.
	// See ListTasksResponse.next_page_token
	PageToken string `protobuf:"bytes,4,opt,name=page_token,json=pageToken" json:"page_token,omitempty"`
}

func (m *ListTasksRequest) Reset()                    { *m = ListTasksRequest{} }
func (m *ListTasksRequest) String() string            { return proto.CompactTextString(m) }
func (*ListTasksRequest) ProtoMessage()               {}
func (*ListTasksRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *ListTasksRequest) GetProject() string {
	if m != nil {
		return m.Project
	}
	return ""
}

func (m *ListTasksRequest) GetNamePrefix() string {
	if m != nil {
		return m.NamePrefix
	}
	return ""
}

func (m *ListTasksRequest) GetPageSize() uint32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListTasksRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

// OUTPUT ONLY
//
// ListTasksResponse describes a response from the ListTasks endpoint.
type ListTasksResponse struct {
	// REQUIRED
	//
	// List of lightweight task descriptions.
	Tasks []*TaskDesc `protobuf:"bytes,1,rep,name=tasks" json:"tasks,omitempty"`
	// OPTIONAL
	//
	// Token used to return the next page of results.
	// See TaskListRequest.next_page_token
	NextPageToken string `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken" json:"next_page_token,omitempty"`
}

func (m *ListTasksResponse) Reset()                    { *m = ListTasksResponse{} }
func (m *ListTasksResponse) String() string            { return proto.CompactTextString(m) }
func (*ListTasksResponse) ProtoMessage()               {}
func (*ListTasksResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *ListTasksResponse) GetTasks() []*TaskDesc {
	if m != nil {
		return m.Tasks
	}
	return nil
}

func (m *ListTasksResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

// OUTPUT ONLY
//
// TaskDesc is a lightweight description of a task, which is returned
// by the ListTasks endpoint.
type TaskDesc struct {
	// REQUIRED
	//
	// Task identifier.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// REQUIRED
	State State `protobuf:"varint,2,opt,name=state,enum=tes.State" json:"state,omitempty"`
}

func (m *TaskDesc) Reset()                    { *m = TaskDesc{} }
func (m *TaskDesc) String() string            { return proto.CompactTextString(m) }
func (*TaskDesc) ProtoMessage()               {}
func (*TaskDesc) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *TaskDesc) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *TaskDesc) GetState() State {
	if m != nil {
		return m.State
	}
	return State_UNKNOWN
}

// CancelTaskRequest describes a request to the CancelTask endpoint.
type CancelTaskRequest struct {
	// REQUIRED
	//
	// Task identifier.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *CancelTaskRequest) Reset()                    { *m = CancelTaskRequest{} }
func (m *CancelTaskRequest) String() string            { return proto.CompactTextString(m) }
func (*CancelTaskRequest) ProtoMessage()               {}
func (*CancelTaskRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *CancelTaskRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

// OUTPUT ONLY
//
// CancelTaskResponse describes a response from the CancelTask endpoint.
type CancelTaskResponse struct {
}

func (m *CancelTaskResponse) Reset()                    { *m = CancelTaskResponse{} }
func (m *CancelTaskResponse) String() string            { return proto.CompactTextString(m) }
func (*CancelTaskResponse) ProtoMessage()               {}
func (*CancelTaskResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

// ServiceInfoRequest describes a request to the ServiceInfo endpoint.
type ServiceInfoRequest struct {
}

func (m *ServiceInfoRequest) Reset()                    { *m = ServiceInfoRequest{} }
func (m *ServiceInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*ServiceInfoRequest) ProtoMessage()               {}
func (*ServiceInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

// OUTPUT ONLY
//
// ServiceInfo describes information about the service,
// such as storage details, resource availability,
// and other documentation.
type ServiceInfo struct {
	// OPTIONAL
	//
	// System specific key/value pairs
	// Example for a shared file system based storage system:
	// storageType=sharedFile, baseDir=/path/to/shared/directory
	StorageConfig map[string]string `protobuf:"bytes,1,rep,name=storage_config,json=storageConfig" json:"storage_config,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *ServiceInfo) Reset()                    { *m = ServiceInfo{} }
func (m *ServiceInfo) String() string            { return proto.CompactTextString(m) }
func (*ServiceInfo) ProtoMessage()               {}
func (*ServiceInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *ServiceInfo) GetStorageConfig() map[string]string {
	if m != nil {
		return m.StorageConfig
	}
	return nil
}

func init() {
	proto.RegisterType((*CreateTaskRequest)(nil), "tes.CreateTaskRequest")
	proto.RegisterType((*TaskParameter)(nil), "tes.TaskParameter")
	proto.RegisterType((*Ports)(nil), "tes.Ports")
	proto.RegisterType((*Executor)(nil), "tes.Executor")
	proto.RegisterType((*Resources)(nil), "tes.Resources")
	proto.RegisterType((*GetTaskRequest)(nil), "tes.GetTaskRequest")
	proto.RegisterType((*Task)(nil), "tes.Task")
	proto.RegisterType((*TaskLog)(nil), "tes.TaskLog")
	proto.RegisterType((*ExecutorLog)(nil), "tes.ExecutorLog")
	proto.RegisterType((*OutputFileLog)(nil), "tes.OutputFileLog")
	proto.RegisterType((*ListTasksRequest)(nil), "tes.ListTasksRequest")
	proto.RegisterType((*ListTasksResponse)(nil), "tes.ListTasksResponse")
	proto.RegisterType((*TaskDesc)(nil), "tes.TaskDesc")
	proto.RegisterType((*CancelTaskRequest)(nil), "tes.CancelTaskRequest")
	proto.RegisterType((*CancelTaskResponse)(nil), "tes.CancelTaskResponse")
	proto.RegisterType((*ServiceInfoRequest)(nil), "tes.ServiceInfoRequest")
	proto.RegisterType((*ServiceInfo)(nil), "tes.ServiceInfo")
	proto.RegisterEnum("tes.FileType", FileType_name, FileType_value)
	proto.RegisterEnum("tes.State", State_name, State_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for TaskService service

type TaskServiceClient interface {
	// GetServiceInfo provides information about the service,
	// such as storage details, resource availability, and
	// other documentation.
	GetServiceInfo(ctx context.Context, in *ServiceInfoRequest, opts ...grpc.CallOption) (*ServiceInfo, error)
	// Create a new task.
	CreateTask(ctx context.Context, in *CreateTaskRequest, opts ...grpc.CallOption) (*Task, error)
	// List tasks.
	ListTasks(ctx context.Context, in *ListTasksRequest, opts ...grpc.CallOption) (*ListTasksResponse, error)
	// Get a task.
	GetTask(ctx context.Context, in *GetTaskRequest, opts ...grpc.CallOption) (*Task, error)
	// Cancel a task.
	CancelTask(ctx context.Context, in *CancelTaskRequest, opts ...grpc.CallOption) (*CancelTaskResponse, error)
}

type taskServiceClient struct {
	cc *grpc.ClientConn
}

func NewTaskServiceClient(cc *grpc.ClientConn) TaskServiceClient {
	return &taskServiceClient{cc}
}

func (c *taskServiceClient) GetServiceInfo(ctx context.Context, in *ServiceInfoRequest, opts ...grpc.CallOption) (*ServiceInfo, error) {
	out := new(ServiceInfo)
	err := grpc.Invoke(ctx, "/tes.TaskService/GetServiceInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) CreateTask(ctx context.Context, in *CreateTaskRequest, opts ...grpc.CallOption) (*Task, error) {
	out := new(Task)
	err := grpc.Invoke(ctx, "/tes.TaskService/CreateTask", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) ListTasks(ctx context.Context, in *ListTasksRequest, opts ...grpc.CallOption) (*ListTasksResponse, error) {
	out := new(ListTasksResponse)
	err := grpc.Invoke(ctx, "/tes.TaskService/ListTasks", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) GetTask(ctx context.Context, in *GetTaskRequest, opts ...grpc.CallOption) (*Task, error) {
	out := new(Task)
	err := grpc.Invoke(ctx, "/tes.TaskService/GetTask", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskServiceClient) CancelTask(ctx context.Context, in *CancelTaskRequest, opts ...grpc.CallOption) (*CancelTaskResponse, error) {
	out := new(CancelTaskResponse)
	err := grpc.Invoke(ctx, "/tes.TaskService/CancelTask", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for TaskService service

type TaskServiceServer interface {
	// GetServiceInfo provides information about the service,
	// such as storage details, resource availability, and
	// other documentation.
	GetServiceInfo(context.Context, *ServiceInfoRequest) (*ServiceInfo, error)
	// Create a new task.
	CreateTask(context.Context, *CreateTaskRequest) (*Task, error)
	// List tasks.
	ListTasks(context.Context, *ListTasksRequest) (*ListTasksResponse, error)
	// Get a task.
	GetTask(context.Context, *GetTaskRequest) (*Task, error)
	// Cancel a task.
	CancelTask(context.Context, *CancelTaskRequest) (*CancelTaskResponse, error)
}

func RegisterTaskServiceServer(s *grpc.Server, srv TaskServiceServer) {
	s.RegisterService(&_TaskService_serviceDesc, srv)
}

func _TaskService_GetServiceInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ServiceInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).GetServiceInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tes.TaskService/GetServiceInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).GetServiceInfo(ctx, req.(*ServiceInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_CreateTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).CreateTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tes.TaskService/CreateTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).CreateTask(ctx, req.(*CreateTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_ListTasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTasksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).ListTasks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tes.TaskService/ListTasks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).ListTasks(ctx, req.(*ListTasksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_GetTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).GetTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tes.TaskService/GetTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).GetTask(ctx, req.(*GetTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskService_CancelTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskServiceServer).CancelTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tes.TaskService/CancelTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskServiceServer).CancelTask(ctx, req.(*CancelTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _TaskService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tes.TaskService",
	HandlerType: (*TaskServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetServiceInfo",
			Handler:    _TaskService_GetServiceInfo_Handler,
		},
		{
			MethodName: "CreateTask",
			Handler:    _TaskService_CreateTask_Handler,
		},
		{
			MethodName: "ListTasks",
			Handler:    _TaskService_ListTasks_Handler,
		},
		{
			MethodName: "GetTask",
			Handler:    _TaskService_GetTask_Handler,
		},
		{
			MethodName: "CancelTask",
			Handler:    _TaskService_CancelTask_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "tes.proto",
}

func init() { proto.RegisterFile("tes.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1364 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x57, 0xcf, 0x6f, 0xe3, 0xc4,
	0x17, 0x5f, 0xe7, 0xa7, 0xfd, 0xd2, 0xe4, 0xeb, 0xce, 0x77, 0xb7, 0x35, 0xd9, 0x5d, 0x08, 0x2e,
	0x42, 0x55, 0x59, 0x5a, 0xe8, 0xae, 0xf8, 0x51, 0x38, 0x50, 0x52, 0x6f, 0x15, 0x68, 0xd3, 0x32,
	0x49, 0x85, 0x16, 0x0e, 0xc1, 0x75, 0x66, 0xb3, 0xa6, 0x89, 0xc7, 0xcc, 0x4c, 0xca, 0xb6, 0x88,
	0x0b, 0xe2, 0xc2, 0x0d, 0x89, 0x23, 0x27, 0x24, 0x4e, 0x08, 0x89, 0x3f, 0x85, 0x03, 0x77, 0x4e,
	0xfc, 0x21, 0x68, 0xc6, 0xe3, 0xc4, 0x49, 0xb6, 0x2b, 0x55, 0xdc, 0xe6, 0x7d, 0xde, 0xc7, 0x6f,
	0xde, 0xef, 0x91, 0xc1, 0x12, 0x84, 0x6f, 0xc6, 0x8c, 0x0a, 0x8a, 0xf2, 0x82, 0xf0, 0xfa, 0x9d,
	0x01, 0xa5, 0x83, 0x21, 0xd9, 0xf2, 0xe3, 0x70, 0xcb, 0x8f, 0x22, 0x2a, 0x7c, 0x11, 0xd2, 0x48,
	0x53, 0xdc, 0x5f, 0xf2, 0xb0, 0xdc, 0x64, 0xc4, 0x17, 0xa4, 0xeb, 0xf3, 0x33, 0x4c, 0xbe, 0x1a,
	0x13, 0x2e, 0x10, 0x82, 0x42, 0xe4, 0x8f, 0x88, 0x63, 0x34, 0x8c, 0x75, 0x0b, 0xab, 0x33, 0x72,
	0xa0, 0x1c, 0x33, 0xfa, 0x25, 0x09, 0x84, 0x93, 0x53, 0x70, 0x2a, 0xa2, 0x06, 0x54, 0xfa, 0x84,
	0x07, 0x2c, 0x8c, 0xa5, 0x65, 0x27, 0xaf, 0xb4, 0x59, 0x08, 0x6d, 0x40, 0x29, 0x8c, 0xe2, 0xb1,
	0xe0, 0x4e, 0xa1, 0x91, 0x5f, 0xaf, 0x6c, 0xa3, 0x4d, 0xe9, 0xa4, 0xbc, 0xf1, 0xd8, 0x67, 0xfe,
	0x88, 0x08, 0xc2, 0xb0, 0x66, 0xa0, 0x7b, 0x50, 0xa6, 0x63, 0xa1, 0xc8, 0xc5, 0x2b, 0xc9, 0x29,
	0x05, 0xdd, 0x03, 0x8b, 0x11, 0x4e, 0xc7, 0x2c, 0x20, 0xdc, 0x29, 0x35, 0x8c, 0xf5, 0xca, 0x76,
	0x4d, 0xf1, 0x71, 0x8a, 0xe2, 0x29, 0x01, 0xbd, 0x06, 0x16, 0x79, 0x4a, 0x82, 0xb1, 0xa0, 0x8c,
	0x3b, 0xa6, 0xb2, 0x5e, 0x55, 0x6c, 0x4f, 0xa3, 0x78, 0xaa, 0x97, 0x01, 0x9f, 0xd3, 0xe1, 0x78,
	0x44, 0xb8, 0x63, 0x35, 0xf2, 0x32, 0x60, 0x2d, 0xa2, 0x07, 0x50, 0x10, 0xfe, 0x80, 0x3b, 0xa0,
	0x2c, 0x34, 0x94, 0x85, 0x85, 0x24, 0x6e, 0x76, 0xfd, 0x01, 0xf7, 0x22, 0xc1, 0x2e, 0xb0, 0x62,
	0xd7, 0xdf, 0x06, 0x6b, 0x02, 0x21, 0x1b, 0xf2, 0x67, 0xe4, 0x42, 0x27, 0x58, 0x1e, 0xd1, 0x4d,
	0x28, 0x9e, 0xfb, 0xc3, 0x31, 0xd1, 0xd9, 0x4d, 0x84, 0x9d, 0xdc, 0x3b, 0x86, 0xfb, 0x9b, 0x01,
	0xd5, 0x99, 0xf0, 0x9f, 0x59, 0x9f, 0xb9, 0x2a, 0xe4, 0x16, 0xab, 0x60, 0x43, 0x7e, 0xcc, 0x86,
	0xba, 0x3e, 0xf2, 0x28, 0xed, 0xc4, 0xbe, 0x78, 0xe2, 0x14, 0x12, 0x3b, 0xf2, 0x8c, 0x5e, 0x86,
	0x82, 0xb8, 0x88, 0x89, 0x53, 0x6c, 0x18, 0xeb, 0x35, 0x9d, 0x9e, 0x87, 0xe1, 0x90, 0x74, 0x2f,
	0x62, 0x82, 0x95, 0x0a, 0xd5, 0xc1, 0x0c, 0x68, 0x24, 0x48, 0x24, 0x92, 0x9c, 0x5b, 0x78, 0x22,
	0xbb, 0xef, 0x42, 0xf1, 0x98, 0x32, 0xc1, 0xd1, 0x1d, 0xb0, 0x24, 0xe8, 0x87, 0x11, 0x61, 0xca,
	0xd1, 0x2a, 0x9e, 0x02, 0xf2, 0xe6, 0x27, 0x94, 0x27, 0xad, 0x54, 0xc5, 0xea, 0xec, 0xfe, 0x91,
	0x03, 0x33, 0x2d, 0x04, 0xba, 0x0b, 0x10, 0x8e, 0xfc, 0x01, 0xe9, 0x65, 0x02, 0xb5, 0x14, 0xd2,
	0x96, 0xd1, 0xda, 0x90, 0x0f, 0x46, 0x7d, 0x27, 0xa7, 0x0a, 0x23, 0x8f, 0xb2, 0x5c, 0x5f, 0x53,
	0x76, 0xd6, 0x0f, 0x99, 0x8e, 0x30, 0x15, 0x65, 0x66, 0xb9, 0xe8, 0x87, 0x91, 0xf6, 0x35, 0x11,
	0xd0, 0x0a, 0x94, 0xb8, 0xe8, 0xd3, 0xb1, 0xd0, 0xd1, 0x6b, 0x49, 0xe3, 0x84, 0x31, 0x95, 0x81,
	0x04, 0x27, 0x8c, 0xa1, 0x06, 0x14, 0x63, 0x19, 0x98, 0x53, 0x56, 0x55, 0x07, 0x95, 0x18, 0x15,
	0x2a, 0x4e, 0x14, 0xe8, 0x01, 0x94, 0x49, 0x74, 0x1e, 0x32, 0x1a, 0xe9, 0xde, 0xaa, 0xcf, 0xf4,
	0xd6, 0xa6, 0x97, 0x28, 0x93, 0x9e, 0x48, 0xa9, 0xf5, 0x1d, 0x58, 0xca, 0x2a, 0xae, 0xd5, 0x19,
	0x3f, 0x1a, 0x60, 0x4d, 0x1a, 0x1d, 0xdd, 0x06, 0x2b, 0x88, 0xc7, 0xbd, 0x80, 0x32, 0xc2, 0x75,
	0xc6, 0xcd, 0x20, 0x1e, 0x37, 0xa5, 0x2c, 0xdb, 0x23, 0x66, 0x84, 0x8c, 0x62, 0x11, 0x9e, 0x0e,
	0x13, 0x53, 0x26, 0xce, 0x42, 0xe8, 0x16, 0x94, 0x98, 0x3f, 0xea, 0x0d, 0x4e, 0x55, 0xfe, 0x0c,
	0x5c, 0x64, 0xfe, 0x68, 0xff, 0x14, 0xad, 0x42, 0x99, 0x87, 0x97, 0x44, 0xe2, 0x05, 0x85, 0x97,
	0xa4, 0xb8, 0x7f, 0x2a, 0xdd, 0xba, 0xa4, 0x11, 0x49, 0xc6, 0xd4, 0xc2, 0x89, 0xe0, 0x36, 0xa0,
	0xb6, 0x4f, 0x44, 0x76, 0x99, 0xd4, 0x20, 0x17, 0xf6, 0x75, 0x3c, 0xb9, 0xb0, 0xef, 0xfe, 0x9e,
	0x83, 0x82, 0xd4, 0xcf, 0x2b, 0xd0, 0x7d, 0x30, 0x47, 0x44, 0xf8, 0x7d, 0x5f, 0xf8, 0xaa, 0xb0,
	0x95, 0xed, 0xd5, 0xc9, 0xe8, 0x6f, 0x1e, 0x6a, 0x4d, 0x92, 0xbd, 0x09, 0x11, 0xbd, 0x01, 0x65,
	0x96, 0x5c, 0xa4, 0xdc, 0xae, 0x6c, 0xaf, 0x3c, 0x7b, 0x1c, 0x71, 0x4a, 0x93, 0x85, 0xe4, 0xc2,
	0x17, 0x44, 0x85, 0x53, 0xd3, 0x85, 0xec, 0x48, 0x04, 0x27, 0x0a, 0xd4, 0x80, 0xc2, 0x90, 0x0e,
	0xd2, 0xfd, 0xb3, 0x34, 0x71, 0xe2, 0x80, 0x0e, 0xb0, 0xd2, 0x64, 0x97, 0x54, 0x29, 0xb3, 0xa4,
	0x8e, 0x14, 0x26, 0xa7, 0x45, 0x52, 0x53, 0x4a, 0xfd, 0x3d, 0xa8, 0xce, 0xb8, 0x7f, 0xad, 0x1a,
	0xff, 0x6d, 0x40, 0x59, 0x5f, 0x8e, 0x5e, 0xd1, 0x8e, 0x19, 0xea, 0x4e, 0x7b, 0xa6, 0xbd, 0xa6,
	0xce, 0xbd, 0xb5, 0x90, 0xc7, 0x7a, 0x36, 0x84, 0x2b, 0x53, 0x79, 0x17, 0x80, 0x0b, 0x9f, 0x89,
	0x9e, 0x08, 0x47, 0x44, 0x0f, 0x91, 0xa5, 0x90, 0x6e, 0x38, 0x22, 0xe8, 0x05, 0x30, 0x49, 0xd4,
	0x4f, 0x94, 0xc9, 0xc8, 0x94, 0x49, 0xd4, 0x97, 0xaa, 0xff, 0x16, 0xe0, 0x9f, 0x06, 0x54, 0x32,
	0x41, 0xcc, 0xb9, 0x91, 0x7b, 0x9e, 0x1b, 0xf9, 0x19, 0x37, 0xae, 0x3d, 0xd2, 0xb7, 0xe5, 0x73,
	0x10, 0x8a, 0x5e, 0x40, 0xfb, 0x44, 0x2d, 0x87, 0x22, 0x36, 0x25, 0xd0, 0xa4, 0x7d, 0x22, 0xfb,
	0x5e, 0x6e, 0xa5, 0x5e, 0x18, 0x3b, 0xe5, 0xe4, 0x2b, 0x29, 0xb6, 0xe2, 0xe9, 0x22, 0x30, 0xaf,
	0x58, 0x04, 0x6e, 0x17, 0xaa, 0x33, 0x9d, 0x90, 0x6e, 0x5e, 0x63, 0x71, 0xf3, 0xe6, 0x32, 0x9b,
	0x57, 0x06, 0x2e, 0x27, 0xed, 0xf4, 0x42, 0x10, 0xae, 0x62, 0xcb, 0x63, 0x4b, 0x22, 0x1f, 0x4a,
	0xc0, 0xfd, 0xc1, 0x00, 0xfb, 0x20, 0xe4, 0x6a, 0xb6, 0x78, 0x3a, 0x5c, 0x99, 0x57, 0xd9, 0x98,
	0x7d, 0x95, 0x5f, 0x82, 0x8a, 0x5c, 0x9d, 0xbd, 0x98, 0x91, 0xc7, 0xe1, 0x53, 0x7d, 0x11, 0x48,
	0xe8, 0x58, 0x21, 0x32, 0xfa, 0x58, 0x2e, 0x58, 0x79, 0x83, 0xba, 0xad, 0x8a, 0x4d, 0x09, 0x74,
	0xc2, 0x4b, 0x22, 0x7d, 0x51, 0x4a, 0x41, 0xcf, 0x48, 0xa4, 0xd3, 0xa9, 0xe8, 0x5d, 0x09, 0xb8,
	0x5f, 0xc0, 0x72, 0xc6, 0x15, 0x1e, 0xd3, 0x88, 0x13, 0xb4, 0x06, 0x45, 0x21, 0x01, 0xdd, 0x9e,
	0xd5, 0x49, 0xd3, 0xed, 0x11, 0x1e, 0xe0, 0x44, 0x87, 0x5e, 0x85, 0xff, 0x45, 0xe4, 0xa9, 0xe8,
	0x65, 0xac, 0x27, 0xae, 0x55, 0x25, 0x7c, 0x3c, 0xb9, 0xe1, 0x7d, 0x30, 0xd3, 0x4f, 0x17, 0x16,
	0xc5, 0x64, 0x82, 0x73, 0x57, 0x4c, 0xb0, 0xbb, 0x06, 0xcb, 0x4d, 0x3f, 0x0a, 0xc8, 0xf0, 0x79,
	0x8b, 0xe8, 0x26, 0xa0, 0x2c, 0x29, 0x89, 0x42, 0xa2, 0x1d, 0xc2, 0xce, 0xc3, 0x80, 0xb4, 0xa2,
	0xc7, 0x54, 0x7f, 0xeb, 0xfe, 0x6c, 0x40, 0x25, 0x03, 0xa3, 0x8f, 0xa0, 0xc6, 0x05, 0x65, 0x32,
	0x88, 0x80, 0x46, 0x8f, 0xc3, 0x81, 0x0e, 0x7a, 0x2d, 0xf1, 0x65, 0xca, 0xdc, 0xec, 0x24, 0xb4,
	0xa6, 0x62, 0x25, 0x23, 0x57, 0xe5, 0x59, 0xac, 0xfe, 0x01, 0xa0, 0x45, 0xd2, 0x75, 0x46, 0x68,
	0x63, 0x0d, 0xcc, 0xf4, 0x89, 0x46, 0x26, 0x14, 0x1e, 0xb6, 0x0e, 0x3c, 0xfb, 0x06, 0xaa, 0x82,
	0xb5, 0xd7, 0xc2, 0x5e, 0xb3, 0x7b, 0x84, 0x1f, 0xd9, 0xc6, 0xc6, 0xf7, 0x06, 0x14, 0x55, 0x92,
	0x50, 0x05, 0xca, 0x27, 0xed, 0x8f, 0xdb, 0x47, 0x9f, 0xb6, 0xed, 0x1b, 0x08, 0xa0, 0xf4, 0xc9,
	0x89, 0x77, 0xe2, 0xed, 0xd9, 0x06, 0xb2, 0x61, 0xa9, 0xd5, 0x6e, 0x75, 0x5b, 0xbb, 0x07, 0xad,
	0xcf, 0x5a, 0xed, 0x7d, 0x3b, 0x27, 0xa9, 0xf8, 0xa4, 0xdd, 0x96, 0x42, 0x5e, 0x52, 0x8f, 0x77,
	0x4f, 0x3a, 0xde, 0x9e, 0x5d, 0x40, 0x4b, 0x60, 0x36, 0x8f, 0x0e, 0x8f, 0x0f, 0xbc, 0xae, 0x67,
	0x17, 0x91, 0x05, 0x45, 0x0f, 0xe3, 0x23, 0x6c, 0x97, 0xa4, 0x8d, 0xce, 0xa3, 0x4e, 0xd7, 0x3b,
	0xec, 0x25, 0x48, 0x59, 0x51, 0x77, 0xdb, 0x4d, 0xef, 0xc0, 0xdb, 0xb3, 0xcd, 0xed, 0x5f, 0xf3,
	0x50, 0x91, 0x09, 0xd7, 0x39, 0x42, 0x9f, 0xab, 0x07, 0x23, 0x9b, 0xdb, 0xd5, 0xf9, 0x1c, 0xea,
	0x22, 0xd4, 0xed, 0x79, 0x85, 0xfb, 0xe2, 0x77, 0x7f, 0xfd, 0xf3, 0x53, 0xce, 0x41, 0x2b, 0x5b,
	0xe7, 0x6f, 0x6e, 0xa9, 0x06, 0xdb, 0xe2, 0x89, 0xfa, 0xf5, 0x50, 0x9a, 0xf2, 0x00, 0xa6, 0x2f,
	0x01, 0xba, 0xe2, 0x69, 0xa8, 0x5b, 0x93, 0x4e, 0x75, 0x6f, 0x2a, 0x83, 0x35, 0xd7, 0x9a, 0x18,
	0xdc, 0x31, 0x36, 0xd0, 0x21, 0x58, 0x93, 0x76, 0x47, 0xb7, 0x14, 0x7b, 0x7e, 0x12, 0xeb, 0x2b,
	0xf3, 0xb0, 0xee, 0xa7, 0x65, 0x65, 0xb1, 0x82, 0xa6, 0x16, 0xd1, 0x2e, 0x94, 0xf5, 0x1b, 0x89,
	0xfe, 0xaf, 0xbe, 0x9a, 0x7d, 0x31, 0xb3, 0xfe, 0xac, 0xa8, 0xaf, 0x6d, 0x54, 0x9b, 0x06, 0xf8,
	0x4d, 0xd8, 0xff, 0x16, 0xf5, 0x00, 0xa6, 0xbd, 0x9b, 0x06, 0x36, 0xdf, 0xf1, 0xf5, 0xd5, 0x05,
	0x5c, 0x3b, 0xd5, 0x50, 0x66, 0xeb, 0xee, 0xad, 0x59, 0xb3, 0x3b, 0x81, 0xa2, 0xee, 0x18, 0x1b,
	0xa7, 0x25, 0xf5, 0x7f, 0x70, 0xff, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xbd, 0xb3, 0x63, 0x5d,
	0x4f, 0x0c, 0x00, 0x00,
}
